#!/usr/bin/perl
# vim: ts=2:sw=2:et:syntax=perl

use Mojolicious::Lite;
use MIME::Entity;

use IO::Compress::Gzip qw(gzip $GzipError) ;

# Configuration
# TODO: read from separate config file
my $domain = 'taz.net.au';   # domain name appended to each VM's hostname
app->secrets(['changeme']);
# End of config

my $debug = app->mode eq 'development';

hook after_render => sub {
  my ($c, $output, $format) = @_;
 
  # Check if "gzip => 1" has been set in the stash
  return unless $c->stash->{gzip};
 
  # Check if user agent accepts gzip compression
  return unless ($c->req->headers->accept_encoding // '') =~ /gzip/i;

  # set headers
  $c->res->headers->append(Vary => 'Accept-Encoding');
  $c->res->headers->content_encoding('gzip');
 
  # Compress content with gzip
  gzip $output, \my $compressed;
  $$output = $compressed;
};

my %dhcp;
parse_dhcp(\%dhcp);

helper ip => sub {
  my $c = shift;
  return $c->tx->remote_address;
};

helper fmt => sub {
  my $c = shift;
  # browsable links in a browser, text/plain for cloud-init and command-line testing.
  my $fmt = 'html';
  $fmt = 'txt' if ($c->req->headers->user_agent =~ /Cloud-Init|Mojolicious|curl|wget|libwww-perl/);
  return $fmt;
};

helper hostname => sub {
  my $c = shift;

  my $host = $dhcp{$c->tx->remote_address}->{'host'};
  # allow ?host= to override (for testing)
  $host = $c->param('host') if defined($c->param('host'));

  return $host;
};

helper fqdn => sub {
  my $c = shift;
  return $c->hostname . '.' . $domain;
};

helper mac => sub {
  my $c = shift;
  return $dhcp{$c->tx->remote_address}->{'mac'};
};

helper instance_id => sub {
  my $c = shift;

  # re-use the same time for a while - cloud-init fetches instance-id
  # repeatedly during boot.  10 seconds should be plenty.
  my ($now);
  our ($instance_time);
  $now = int(time);
  $instance_time = $now if ((!defined($instance_time)) || ($now - 10 gt $instance_time));

  return 'i-' . $c->hostname . '-' . $instance_time;
};

get '/' => sub {
  my $c = shift;

  $c->stash(links => [ qw(1.0/ 2009-04-04/ latest/) ] );
  $c->render(template => 'print_links', format => $c->fmt);
};

if ($debug) {
  get '/dump*dump' => sub {
    my $c = shift;
    my $dump = $c->stash('dump');

    use Data::Dump qw(pp);

    if ($dump eq '/dhcp') {
      $c->render(text => pp(\%dhcp), format => 'txt');
    } elsif ($dump eq '/app') {
      $c->render(text => pp(app), format => 'txt');
    } elsif ($dump eq '/c') {
      $c->render(text => pp(\$c), format => 'txt');
    } else {
      $c->stash(links => [ qw(dhcp app c) ] );
      $c->render(template => 'print_links', format => $c->fmt);
    };
  };
};


group {
  get '/1.0'    => sub { my $c=shift ; $c->redirect_to('/2009-04-04/') };
  get '/latest' => sub { my $c=shift ; $c->redirect_to('/2009-04-04/') };

  under '/2009-04-04';

  get '/' => sub {
    my $c = shift;
    $c->stash(links => [ qw(meta-data/ user-data/) ] );
    $c->render(template => 'print_links', format => $c->fmt);
  };

  get '/user-data' => sub {
    my $c = shift;

    my $top = MIME::Entity->build(Type => 'multipart/mixed');
    my $udpath = './userdata';

    my $host = $c->hostname;

    my %filetypes;
    if (! %filetypes) {
      %filetypes = ('hostkeys'    => 'text/cloud-config',
                    'authkeys'    => 'text/cloud-config',
                    'userdata'    => 'text/cloud-config',
                    'shellscript' => 'text/x-shellscript',
                   );
    };

    # cloud-init merges multiple attachments of the same type. documented at
    # http://cloudinit.readthedocs.io/en/latest/topics/merging.html
    foreach my $udfile (sort keys %filetypes) {

      # all hosts get the files in the $udpath/all directory (unless that
      # host has an exclude-all or exclude-all-$udfile file to prevent it)
      if ( (-e "$udpath/all/$udfile") && 
           ( ! (-e "$udpath/$host/exclude-all" || 
                -e "$udpath/$host/exclude-all-$udfile"
               )
           )
         ) {

        $top->attach(Path => "$udpath/all/$udfile" , 
                     Type => $filetypes{$udfile}, 
                     Filename => "$udfile-all");

      };

      # then they get $udpath/$host/$udfile if it exists, otherwise they
      # get $udpath/default/$udfile (if that exists).
      my $hostudfile='';
      my $hostudpath='';
      $hostudpath="$udpath/default" if (-e "$udpath/default/$udfile");
      $hostudpath="$udpath/$host"   if (-e "$udpath/$host/$udfile");

      $hostudfile = "$udpath/$hostudpath/$udfile" if ($hostudpath ne '');

      if (-e $hostudfile) {
        $top->attach(Path => $hostudfile, 
                     Type => $filetypes{$udfile}, 
                     Filename => "$udfile-$hostudpath");
      };

    };

    $c->render(text => $top->as_string, format => 'txt', gzip => 1);
  };

  under '/2009-04-04/meta-data';

  get '/#request' => {request => 'index' }  => sub {
    my $c = shift;

    my $r = $c->stash('request');                                               

    if ($r eq 'index') {
      $c->stash(links => [ 
            sort qw(
                    ami-id ami-launch-index ami-manifest-path hostname
                    instance-id instance-type local-hostname local-ipv4
                    public-hostname public-ipv4 reservation-id
                    security-groups
                   )
                   #  block-device-mapping/ public-keys/ placement/
              ]);

      $c->render(template => 'print_links', format => $c->fmt);

    } else {

      my $txt = '';

      if    ($r eq 'ami-id')            { $txt = 'ami-fake' }
      elsif ($r eq 'ami-launch-index')  { $txt = '0' }
      elsif ($r eq 'ami-manifest-path') { $txt = 'unknown' }
      elsif ($r eq 'reservation-id')    { $txt = 'r-fake' }
      elsif ($r eq 'security-groups')   { $txt = 'none' }
      elsif ($r eq 'instance-type')     { $txt = 't2.medium' }
      elsif ($r eq 'instance-id')       { $txt = $c->instance_id }
      elsif ($r eq 'hostname')          { $txt = $c->fqdn }
      elsif ($r eq 'public-hostname')   { $txt = $c->fqdn }
      elsif ($r eq 'public-ipv4')       { $txt = $c->ip }
      elsif ($r eq 'local-ipv4')        { $txt = $c->ip }
      elsif ($r eq 'local-hostname')    { $txt = $c->fqdn }
      elsif ($r eq 'mac')               { $txt = $c->mac }
      ;

      $c->render(format => 'txt', text => $txt) 
    }
  };
};


app->start;

###
### subroutines
###

sub parse_dhcp {
  my $dhcp = $_;

  #my $filename = '/etc/dhcp/fixed.txt';
  my $filename = './hosts.txt';
  our $last_parsed = 0 if (!defined $last_parsed);

  my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
      $atime,$mtime,$ctime,$blksize,$blocks) = stat($filename);

  # do nothing if file hasn't changed
  return if ($last_parsed ge $mtime);

  $last_parsed = $mtime;
  $dhcp = ();

  # localhost entries for testing in a browser or from command-line
  $dhcp{'127.0.0.1'}->{'host'} = 'localhost';
  $dhcp{'127.0.0.1'}->{'mac'}  = '01:02:03:04:05:06';
  
  open(DHCP,'<',$filename) || die "couldn't open $filename: $!\n";
  while(<DHCP>) {
    s/^\s*|\s*$|#.*//g;
    next if (/^$/);
  
    my ($host,$mac,$ip) = split ;

    $dhcp{$ip}->{'host'} = $host;
    $dhcp{$ip}->{'mac'} = $mac;
  };
  close(DHCP);
};

__DATA__

@@ print_links.txt.ep
% my $output='';
% foreach my $link (@$links) {
%   $output .= "$link\n"
% };
% return $output;

@@ print_links.html.ep
% my $output='';
% foreach my $link (@$links) {
%   $output .= "<a href=\"$link\">$link</a><br />\n"
% };
% return $output;

